# -*- coding: utf-8 -*-
"""03_list_tuples_more.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/135aqyVgIuW0TQ6SkBLFqGqf6eVvzZicE

Introduciendo las listas
===
Ejemplo
---
Una lista es una colección de elementos, que se almacena en una variable. Los elementos deben estar relacionados de alguna manera, pero no hay restricciones sobre lo que se puede almacenar en una lista. Este es un ejemplo simple de una lista y cómo podemos acceder rápidamente a cada elemento de la lista.
"""

students = ['carlos', 'aaron', 'michael']

for student in students:
    print("Hello, " + student.title() + "!")

"""Nombrar y definir una lista
---
Dado que las listas son una colección de objetos, es una buena práctica darles un nombre en plural. Si cada artículo de tu lista es un automóvil, llama a la lista 'autos'. Si cada artículo es un perro, llama a tu lista 'perros'. Esto proporciona una forma sencilla de referirse a la lista completa ('perros') y a un solo elemento de la lista ('perro').

En Python, los corchetes designan una lista. Para definir una lista, indica el nombre de la lista, el signo de igual y los valores que desea incluir en su lista entre corchetes.
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

"""Accediendo a un elemento en una lista
---
Los elementos de una lista se identifican por su posición en la lista, comenzando con cero.

Para acceder al primer elemento de una lista, debes dar el nombre de la lista, seguido de un cero entre paréntesis.
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

dog = dogs[0]
print(dog.title())

"""El número entre paréntesis se llama el **índice** del elemento. Debido a que las listas comienzan en cero, el índice de un elemento siempre es uno menos que su posición en la lista. Entonces, para obtener el segundo elemento de la lista, necesitamos usar un índice de 1."""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

dog = dogs[1]
print(dog.title())

"""### Accediendo a los últimos elementos en una lista
Probablemente puedas ver que para obtener el último elemento de esta lista, usaríamos un índice de 2. Esto funciona, pero solo funcionaría porque nuestra lista tiene exactamente tres elementos. Para obtener el último elemento de una lista, independientemente de la longitud de la lista, puede utilizar un índice de -1.
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

dog = dogs[-1]
print(dog.title())

"""Esta sintaxis también funciona para el segundo al último elemento, el tercero para el último y así sucesivamente."""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

dog = dogs[-2]
print(dog.title())

"""Sin embargo, no puede utilizar un número negativo mayor que la longitud de la lista."""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

dog = dogs[-4]
print(dog.title()) #:(

"""<a id="Ejercicios"> </a> Ejercicios
---
#### Primera Lista
- Almacena los valores 'python', 'c' y 'java' en una lista. Imprime cada uno de estos valores, utilizando su posición en la lista.

#### Primera lista ordenada
- Almacena los valores 'python', 'c' y 'java' en una lista. Imprime una declaración sobre cada uno de estos valores, utilizando su posición en la lista.
- Tu declaración podría ser simplemente: 'Un lenguaje de programación agradable es *valor*.'

#### Tu primera lista
- Piensa en algo que puedas almacenar en una lista. Haz una lista con tres o cuatro elementos, y luego imprime un mensaje que incluya al menos un elemento de tu lista. Tu oración podría ser tan simple como: "Un elemento de mi lista es un ____".

Listas y bucles
===

Accediendo a todos los elementos en una lista.
---
Este es uno de los conceptos más importantes relacionados con las listas. Puede tener una lista con un millón de elementos en ella, y en tres líneas de código puedes escribir una oración para cada uno de esos millones de elementos. Si deseas comprender las listas y convertirte en un programador competente, asegúrate de tomarte el tiempo para comprender esta sección.

Usamos un bucle para acceder a todos los elementos en una lista. Un bucle es un bloque de código que se repite hasta que se queda sin elementos para trabajar o hasta que se cumple una determinada condición. En este caso, nuestro bucle se ejecutará una vez para cada elemento de nuestra lista. Con una lista de tres elementos, nuestro bucle se ejecutará tres veces.

Echemos un vistazo a cómo accedemos a todos los elementos en una lista, y luego trataremos de entender cómo funciona.
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

for dog in dogs:
    print(dog)

"""Ya hemos visto cómo crear una lista, por lo que realmente estamos tratando de entender cómo funcionan las dos últimas líneas. Estas dos últimas líneas forman un bucle, y el lenguaje aquí puede ayudarnos a ver lo que está sucediendo:

    for dog in dogs:

- La palabra clave "para" le dice a Python que se prepare para usar un bucle.
- La variable "perro", sin ninguna "s", es una variable de marcador de posición temporal. Esta es la variable en la que Python colocará cada elemento en la lista, uno a la vez.
- La primera vez a través del bucle, el valor de "perro" será 'border collie'.
- La segunda vez a través del bucle, el valor de "perro" será "perro de ganado australiano".
- La tercera vez, "perro" será "labrador retriever".
- Después de esto, no hay más elementos en la lista, y el bucle terminará.


### Haciendo más con cada item

Podemos hacer lo que queramos con el valor de "perro" dentro del bucle. En este caso, acabamos de imprimir el nombre del perro.

    print(dog)

No estamos limitados a simplemente imprimir la palabra perro. Podemos hacer lo que queramos con este valor, y esta acción se llevará a cabo para cada elemento de la lista. Digamos algo sobre cada perro en nuestra lista.
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

for dog in dogs:
    print('I like ' + dog + 's.')

"""Python utiliza la sangría para decidir qué hay dentro del bucle y qué está fuera del bucle. El código que está dentro del bucle se ejecutará para cada elemento de la lista. El código que no está sangrado, que viene después del bucle, se ejecutará una vez como el código normal."""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

for dog in dogs:
    print('I like ' + dog + 's.')
    print('No, I really really like ' + dog +'s!\n')
    
print("\nThat's just how I feel about dogs.")

"""Observa que la última línea solo se ejecuta una vez, una vez que se completa el ciclo. Observa también el uso de nuevas líneas ("\n") para facilitar la lectura de la salida.

Enumerar una lista
---
Cuando recorras una lista, es posible que desees conocer el índice del elemento actual. Siempre se puede usar la sintaxis *list.index(valor)*, pero hay una forma más sencilla. La función *enumerate()* rastrea el índice de cada elemento por ti, a medida que recorre la lista:
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

print("Results for the dog show are as follows:\n")
for index, dog in enumerate(dogs):
    place = str(index)
    print("Place: " + place + " Dog: " + dog.title())

"""Para enumerar una lista, debes agregar una variable *index* para mantener el índice actual. Así que en lugar de

    for dog in dogs:
    
Tienes

    for index, dog in enumerate(dogs)
    
El valor en la variable *índice* es siempre un número entero. Si desea imprimirlo en una cadena, debe convertir el entero en una cadena:

    str(index)
    
El índice siempre comienza en 0, por lo que en este ejemplo el valor de *place* debería ser el índice actual, más uno:
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

print("Results for the dog show are as follows:\n")
for index, dog in enumerate(dogs):
    place = str(index + 1)
    print("Place: " + place + " Dog: " + dog.title())

"""### Un error de bucle común
Un error de bucle común ocurre cuando en lugar de usar la única variable *dog* dentro del bucle, accidentalmente usamos la variable que contiene la lista completa:
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

for dog in dogs:
    print(dogs)

"""En este ejemplo, en lugar de imprimir cada perro en la lista, imprimimos la lista completa cada vez que pasamos por el bucle. Python coloca cada elemento individual de la lista en la variable *dog*, pero nunca usamos esa variable. A veces solo obtendrás un error si intentas hacer esto:"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

for dog in dogs:
    print('I like ' + dog + 's.')

"""Ejercicios
---
#### Primera Lista - Loop
- Repite *Primera lista*, pero esta vez use un bucle para imprimir cada valor en la lista.

#### Primera lista ordenada - Loop
- Repite *Primera lista ordenada*, pero esta vez use un bucle para imprimir sus declaraciones. Asegúrese de que está escribiendo la misma oración para todos los valores en su lista. Los bucles no son efectivos cuando intenta generar una salida diferente para cada valor en su lista.

#### Tu primera lista - Loop
- Repite *Tu primera lista*, pero esta vez use un bucle para imprimir su mensaje para cada elemento de su lista. Nuevamente, si se le ocurrieron diferentes mensajes para cada valor en su lista, elija un mensaje para repetir para cada valor en su lista.

Operaciones comunes en listas
===

Modificar elementos en una lista
---
Puedes cambiar el valor de cualquier elemento en una lista si conoces la posición de ese elemento.
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

dogs[0] = 'chihuahua'
print(dogs)

"""Encontrar un elemento en una lista
---
Si deseas averiguar la posición de un elemento en una lista, puedes utilizar la función *index()*.
"""

dogs.index?

dogs = ['salchicha', 'dalmata', 'chihuahua']

print(dogs.index('chihuahua'))

"""Este método devuelve un ValueError si el elemento solicitado no está en la lista."""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

print(dogs.index('poodle'))

"""Comprobar si un elemento está en una lista
---
Puedes probar si un elemento está en una lista usando la palabra clave "in". Esto será más útil después de aprender a usar las sentencias if-else.
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']

print('salchicha' in dogs)
print('poodle' in dogs)

"""Agregar elementos a una lista
---
### Anexando elementos al final de una lista
Podemos agregar un elemento a una lista usando el método *append()*. Este método agrega el nuevo elemento al final de la lista.
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']
dogs.append('poodle')

for dog in dogs:
    print(dog.title() + "s are cool.")

"""### Insertando elementos en una lista
También podemos insertar elementos en cualquier lugar de la lista, utilizando la función **insert()**. Especificamos la posición que queremos que tenga el artículo, y todo desde ese punto en adelante se desplaza una posición a la derecha. En otras palabras, el índice de cada artículo después del nuevo artículo se incrementa en uno.
"""

dogs.insert?

dogs = ['salchicha', 'dalmata', 'labrador retriever']
dogs.insert(1, 'poodle')

print(dogs)

"""Ten en cuenta que debe indicar primero la posición del nuevo elemento y, a continuación, el valor del nuevo elemento. Si lo haces en el orden inverso, obtendrás un error.

Creando una lista vacía
---
Ahora que sabemos cómo agregar elementos a una lista después de crearla, podemos usar las listas de forma más dinámica. Ya no estamos atascados definiendo toda nuestra lista a la vez.

Un enfoque común con las listas es definir una lista vacía y luego permitir que su programa agregue elementos a la lista según sea necesario. Este enfoque funciona, por ejemplo, al comenzar a construir un sitio web interactivo. Su lista de usuarios podría comenzar vacía, y luego, a medida que la gente se registre en el sitio, crecerá. Este es un enfoque simplificado de cómo funcionan realmente los sitios web, pero la idea es realista.

Este es un breve ejemplo de cómo comenzar con una lista vacía, comenzar a llenarla y trabajar con los elementos de la lista. Lo único nuevo aquí es la forma en que definimos una lista vacía, que es solo un conjunto vacío de corchetes.
"""

# Create an empty list to hold our users.
usernames = []

# Add some users.
usernames.append('bernice')
usernames.append('cody')
usernames.append('aaron')

# Greet all of our users.
for username in usernames:
    print("Welcome, " + username.title() + '!')

"""Si no cambiamos el orden en nuestra lista, podemos usar la lista para averiguar quiénes son nuestros usuarios más antiguos y más nuevos."""

# Create an empty list to hold our users.
usernames = []

# Add some users.
usernames.append('carlos')
usernames.append('cody')
usernames.append('michael')

# Greet all of our users.
for username in usernames:
    print("Welcome, " + username.title() + '!')

# Recognize our first user, and welcome our newest user.
print("\nThank you for being our very first user, " + usernames[0].title() + '!')
print("And a warm welcome to our newest user, " + usernames[-1].title() + '!')

"""Ten en cuenta que el código que da la bienvenida a nuestro nuevo usuario siempre funcionará, porque hemos utilizado el índice -1. Si hubiéramos usado el índice 2, siempre obtendríamos el tercer usuario, incluso a medida que nuestra lista de usuarios crece y crece.

Ordenar una lista
---
Podemos ordenar una lista alfabéticamente, en cualquier orden.
"""

students = ['carlos', 'aaron', 'michael']

# Put students in alphabetical order.
students.sort()

# Display the list in its current order.
print("Our students are currently in alphabetical order.")
for student in students:
    print(student.title())

#Put students in reverse alphabetical order.
students.sort(reverse=True)

# Display the list in its current order.
print("\nOur students are now in reverse alphabetical order.")
for student in students:
    print(student.title())

"""### *sorted()* vs. *sort()*
Siempre que consideres ordenar una lista, ten en cuenta que no puedes recuperar el pedido original. Si deseas mostrar una lista en orden ordenado, pero preservar el orden original, puede usar la función *sorted()*. La función *sorted()* también acepta el argumento opcional *reverse = True*.
"""

students = ['carlos', 'aaron', 'michael']

# Display students in alphabetical order, but keep the original order.
print("Here is the list in alphabetical order:")
for student in sorted(students):
    print(student.title())

# Display students in reverse alphabetical order, but keep the original order.
print("\nHere is the list in reverse alphabetical order:")
for student in sorted(students, reverse=True):
    print(student.title())

print("\nHere is the list in its original order:")
# Show that the list is still in its original order.
for student in students:
    print(student.title())

"""### Invertir una lista
Hemos visto tres posibles pedidos para una lista:
- El orden original en el que se creó la lista.
- Orden alfabetico
- Orden alfabético inverso

Podemos utilizar un orden más, y es el reverso del orden original de la lista. La función *reverse()* nos da este orden.
"""

students = ['carlos', 'aaron', 'michael']
students.reverse()

print(students)

"""Ten en cuenta que revertir es permanente, aunque podría continuar con otra llamada a *reverse()* y recuperar el orden original de la lista.

### Ordenar una lista numérica
Todas las funciones de clasificación también funcionan para listas numéricas.
"""

numbers = [1, 3, 4, 2]

# sort() puts numbers in increasing order.
numbers.sort()
print(numbers)

# sort(reverse=True) puts numbers in decreasing order.
numbers.sort(reverse=True)
print(numbers)

numbers = [1, 3, 4, 2]

# sorted() preserves the original order of the list:
print(sorted(numbers))
print(numbers)

numbers = [1, 3, 4, 2]

# The reverse() function also works for numerical lists.
numbers.reverse()
print(numbers)

"""Encontrar la longitud de una lista
---
Puede encontrar la longitud de una lista utilizando la función *len()*.
"""

usernames = ['carlos', 'aaron', 'michael']
user_count = len(usernames)

print(user_count)

type(user_count)

"""Hay muchas situaciones en las que es posible que desee saber cuántos elementos hay en una lista. Si tienes una lista que almacena a sus usuarios, puedes encontrar la longitud de su lista en cualquier momento y saber cuántos usuarios tiene."""

# Create an empty list to hold our users.
usernames = []

# Add some users, and report on how many users we have.
usernames.append('carlos')
user_count = len(usernames)

print("We have " + str(user_count) + " user!")

usernames.append('aaron')
usernames.append('michael')
user_count = len(usernames)

print("We have " + str(user_count) + " users!")

"""En una nota técnica, la función *len()* devuelve un entero, que no se puede imprimir directamente con cadenas. Usamos la función *str()* para convertir el entero en una cadena para que se imprima correctamente:"""

usernames = ['carlos', 'aaron', 'michael']
user_count = len(usernames)

print("This will cause an error: " + user_count) # :(

usernames = ['carlos', 'aaron', 'michael']
user_count = len(usernames)

print("This will work: " + str(user_count))

"""Ejercicios
---
#### Lista de trabajo
- Haz una lista que incluya cuatro carreras, como 'programador' y 'conductor de camión'.
- Usa la función *list.index()* para encontrar el índice de una carrera en su lista.
- Usa la función *in* para mostrar que esta carrera está en su lista.
- Usa la función *append()* para agregar una nueva carrera a su lista.
- Usa la función *insertar()* para agregar una nueva carrera al principio de la lista.
- Usa un bucle para mostrar todas las carreras en su lista.

#### Empezando desde vacío
- Crea la lista con la que terminó en *Lista de trabajo*, pero esta vez inicie su archivo con una lista vacía y rellénelo con las declaraciones *append()*.
- Imprima una declaración que nos diga cuál fue la primera carrera que pensó.
- Imprima una declaración que nos diga cuál fue la última carrera que pensó.

#### Lista de trabajo ordenada
- Comienca con la lista que creó en *Lista de trabajo*.
- Vas a imprimir la lista en varios pedidos diferentes.
- Cada vez que imprima la lista, use un bucle for en lugar de imprimir la lista en bruto.
- Imprima un mensaje cada vez que nos diga en qué orden deberíamos ver la lista.
    - Imprime la lista en su orden original.
    - Imprimir la lista en orden alfabético.
    - Imprime la lista en su orden original.
    - Imprimir la lista en orden alfabético inverso.
    - Imprime la lista en su orden original.
    - Imprima la lista en el orden inverso al que comenzó.
    - Imprime la lista en su orden original.
    - Ordene la lista de forma permanente en orden alfabético y luego imprímala.
    - Ordene la lista de forma permanente en orden alfabético inverso y luego imprímala.

#### Números ordenados
- Haz una lista de 5 números, en orden aleatorio.
- Vas a imprimir la lista en varios pedidos diferentes.
- Cada vez que imprima la lista, use un bucle for en lugar de imprimir la lista en bruto.
- Imprima un mensaje cada vez que nos diga en qué orden deberíamos ver la lista.
    - Imprimir los números en el orden original.
    - Imprimir los números en orden creciente.
    - Imprimir los números en el orden original.
    - Imprimir los números en orden decreciente.
    - Imprime los números en su orden original.
    - Imprima los números en el orden inverso a partir de cómo comenzaron.
    - Imprimir los números en el orden original.
    - Ordene permanentemente los números en orden creciente, y luego imprímalos.
    - Ordene de forma permanente los números en orden descendente y luego imprímalos.

#### Longitud de las listas
- Copia dos o tres de las listas que hiciste de los ejercicios anteriores, o crea dos o tres listas nuevas.
- Imprime una serie de declaraciones que nos digan qué tan larga es cada lista.

Eliminar elementos de una lista
===
Espero que puedan ver ahora que las listas son una estructura dinámica. Podemos definir una lista vacía y luego rellenarla a medida que la información entra en nuestro programa. Para volvernos realmente dinámicos, necesitamos algunas formas de eliminar elementos de una lista cuando ya no los necesitamos. Puede eliminar elementos de una lista a través de su posición o de su valor.

Eliminar objetos por posición
---
Si conoces la posición de un elemento en una lista, puede eliminar ese elemento utilizando el comando *del*. Para utilizar este enfoque, indique el comando *del* y el nombre de su lista, con el índice del elemento que desea mover entre corchetes:
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']
# Remove the first dog from the list.
del dogs[0]

print(dogs)

"""Eliminando artículos por valor
---
También puedes eliminar un elemento de una lista si conoce su valor. Para hacer esto, usamos la función *remove()*. Indique el nombre de la lista, seguido de la palabra eliminar con el valor del elemento que desea eliminar entre paréntesis. Python busca en su lista, encuentra el primer elemento con este valor y lo elimina.
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']
# Remove dalmata from the list.
dogs.remove('dalmata')

print(dogs)

"""Sin embargo, tenga en cuenta que solo se elimina el primer elemento con este valor. Si tiene varios elementos con el mismo valor, tendrá algunos elementos con este valor en su lista."""

letters = ['a', 'b', 'c', 'a', 'b', 'c']
# Remove the letter a from the list.
letters.remove("a")

print(letters)

"""Sacando elementos de una lista
---
Hay un concepto genial en la programación llamada "elementos emergentes" de una colección. Cada lenguaje de programación tiene algún tipo de estructura de datos similar a las listas de Python. Todas estas estructuras se pueden usar como colas, y hay varias formas de procesar los elementos en una cola.

Un enfoque simple es comenzar con una lista vacía y luego agregar elementos a esa lista. Cuando quieras trabajar con los elementos de la lista, siempre toma el último elemento de la lista, hacer algo con él y luego eliminar ese elemento. La función *pop()* facilita esta tarea. Elimina el último elemento de la lista y nos lo entrega para que podamos trabajar con él. Esto es más fácil de mostrar con un ejemplo:
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']
last_dog = dogs.pop()

print(last_dog)
print(dogs)

"""Este es un ejemplo de un enfoque de primero en entrar, último en salir. El primer elemento de la lista sería el último elemento procesado si siguiera utilizando este enfoque. Veremos una implementación completa de este enfoque más adelante, cuando aprendamos acerca de *while* loops.

En realidad, puedes extraer cualquier elemento que desee de una lista, dando el índice del elemento que desea resaltar. Por lo tanto, podríamos hacer un enfoque de primero en entrar, primero en salir al poner el primer item en la lista:
"""

dogs = ['salchicha', 'dalmata', 'labrador retriever']
first_dog = dogs.pop(0)

print(first_dog)
print(dogs)

dogs.pop?

"""Ejercicios
---
#### Gente famosa
- Haz una lista que incluya los nombres de cuatro personas famosas.
- Elimina a cada persona de la lista, una a la vez, usando cada uno de los cuatro métodos que acabamos de ver:
     - Pop el último elemento de la lista, y pop cualquier elemento excepto el último elemento.
     - Eliminar un elemento por su posición y un elemento por su valor.
- Imprime un mensaje que indique que no hay personas famosas en tu lista e imprima su lista para comprobar que está vacía.

Cortar una lista
===
Como una lista es una colección de items, deberíamos poder obtener cualquier subconjunto de esos items. Por ejemplo, si queremos obtener solo los tres primeros elementos de la lista, deberíamos poder hacerlo fácilmente. Lo mismo debería ser cierto para cualquiera de los tres elementos en medio de la lista, o los últimos tres elementos, o cualquier elemento x desde cualquier lugar de la lista. Estos subconjuntos de una lista se denominan *slices*.

Para obtener un subconjunto de una lista, proporcionamos la posición del primer elemento que queremos y la posición del primer elemento que no *queremos* incluir en el subconjunto. Por lo tanto, el sector *list[0:3]* devolverá una lista que contiene los elementos 0, 1 y 2, pero no el elemento 3. A continuación, se muestra cómo obtener un lote que contiene los tres primeros elementos.
"""

usernames = ['carlos', 'cody', 'michael', 'maria', 'dalia']

# Grab the first three users in the list.
first_batch = usernames[0:3]

for user in first_batch:
    print(user.title())

"""Si deseas tomar todo hasta una cierta posición en la lista, también puede dejar el primer índice en blanco:"""

###highlight=[5]
usernames = ['carlos', 'cody', 'michael', 'maria', 'dalia']

# Grab the first three users in the list.
first_batch = usernames[:3]

for user in first_batch:
    print(user.title())

"""Cuando tomamos una porción de una lista, la lista original no se ve afectada:"""

###highlight=[7,8,9]
usernames = ['carlos', 'cody', 'michael', 'maria', 'dalia']

# Grab the first three users in the list.
first_batch = usernames[0:3]

# The original list is unaffected.
for user in usernames:
    print(user.title())

"""Podemos obtener cualquier segmento de una lista que queramos, usando el método de división:"""

usernames = ['carlos', 'cody', 'michael', 'maria', 'dalia']

# Grab a batch from the middle of the list.
middle_batch = usernames[1:4]

for user in middle_batch:
    print(user.title())

"""Para obtener todos los elementos desde una posición en la lista hasta el final de la lista, podemos omitir el segundo índice:"""

usernames = ['carlos', 'cody', 'michael', 'maria', 'dalia']

# Grab all users from the third to the end.
end_batch = usernames[2:]

for user in end_batch:
    print(user.title())

"""### Copiando una lista
Puede usars la notación de división para hacer una copia de una lista, omitiendo tanto el índice inicial como el final. Esto hace que la división conste de todo, desde el primer elemento hasta el último, que es la lista completa.
"""

usernames = ['carlos', 'cody', 'michael', 'maria', 'dalia']

# Make a copy of the list.
copied_usernames = usernames[:]
print("The full copied list:\n\t", copied_usernames)

# Remove the first two users from the copied list.
del copied_usernames[0]
del copied_usernames[0]
print("\nTwo users removed from copied list:\n\t", copied_usernames)

# The original list is unaffected.
print("\nThe original list:\n\t", usernames)

"""Ejercicios
---
#### Rodajas alfabéticas
- Almacenar las primeras diez letras del alfabeto en una lista.
- Use una rebanada para imprimir las primeras tres letras del alfabeto.
- Use una porción para imprimir tres letras del medio de su lista.
- Use un corte para imprimir las letras desde cualquier punto en el medio de su lista, hasta el final.

#### Lista protegida
- Su objetivo en este ejercicio es demostrar que copiar una lista protege la lista original.
- Hacer una lista con los nombres de tres personas en ella.
- Use una porción para hacer una copia de la lista completa.
- Agregue al menos dos nombres nuevos a la nueva copia de la lista.
- Haga un bucle que imprima todos los nombres en la lista original, junto con un mensaje de que esta es la lista original.
- Haga un bucle que imprima todos los nombres en la lista copiada, junto con un mensaje de que esta es la lista copiada.

Listas Numéricas
===
No hay nada especial en las listas de números, pero hay algunas funciones que puede usar para hacer que el trabajo con listas numéricas sea más eficiente. Hagamos una lista de los primeros diez números y comencemos a trabajar con ella para ver cómo podemos usar los números en una lista.
"""

# Print out the first ten numbers.
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for number in numbers:
    print(number)

"""La función *range()*
---
Esto funciona, pero no es muy eficiente si queremos trabajar con un gran número de números. La función *range()* nos ayuda a generar largas listas de números. Aquí hay dos formas de hacer lo mismo, usando la función *rango*.
"""

range(1,11)

# Print the first ten numbers.
for number in range(1,11):
    print(number)

"""La función de rango toma un número inicial y un número final. Obtiene todos los enteros, hasta el número final, pero sin incluirlo. También puede agregar un valor de *paso*, que le dice a la función *rango* qué tan grande es el paso que debe tomar entre números:"""

# Print the first ten odd numbers.
for number in range(1,21,2):
    print(number)

"""Si queremos almacenar estos números en una lista, podemos usar la función * list () *. Esta función toma un rango y la convierte en una lista:"""

# Create a list of the first ten numbers.
numbers = list(range(1,10))
print(numbers)

"""Esto es increíblemente poderoso; Ahora podemos crear una lista de los primeros millones de números, tan fácilmente como hicimos una lista de los primeros diez números. Realmente no tiene sentido imprimir los millones de números aquí, pero podemos mostrar que la lista realmente tiene un millón de elementos en ella, y podemos imprimir los últimos diez elementos para mostrar que la lista es correcta."""

# Store the first million numbers in a list.
numbers = list(range(1,1000001))

# Show the length of the list:
print("The list 'numbers' has " + str(len(numbers)) + " numbers in it.")

# Show the last ten numbers:
print("\nThe last ten numbers in the list are:")
for number in numbers[-10:]:
    print(number)

"""Hay dos cosas aquí que pueden ser un poco confusas. La expresion

     str(len(numbers))

toma la longitud de la lista de *numbers* y la convierte en una cadena que se puede imprimir.

La expresion

     numbers[-10:]

nos da un *slice* de la lista. El índice `-1` es el último elemento de la lista, y el índice` -10` es el elemento diez lugares desde el final de la lista. Así que la división `numbers[-10:]` nos da todo desde ese elemento hasta el final de la lista.

Las funciones *min()*, *max()* y *sum()*
---
Hay tres funciones que puedes usar fácilmente con listas numéricas. Como es de esperar, la función * min () * devuelve el número más pequeño en la lista, la función * max () * devuelve el número más grande en la lista, y la función * sum () * devuelve el total de todos los números en la lista.
"""

ages = [23, 16, 14, 28, 19, 11, 38]

youngest = min(ages)
oldest = max(ages)
total_years = sum(ages)

print("Our youngest reader is " + str(youngest) + " years old.")
print("Our oldest reader is " + str(oldest) + " years old.")
print("Together, we have " + str(total_years) + " years worth of life experience.")

"""Ejercicios
---
#### Primeros veinte
- Use la función *range()* para almacenar los primeros veinte números (1-20) en una lista, e imprímalos.

#### Conjuntos más grandes
- Tome el programa *first \ _twenty.py * que acaba de escribir. Cambie su número final a un número mucho más grande. ¿Cuánto tiempo le toma a su computadora imprimir los primeros millones de números? (La mayoría de las personas nunca verán un millón de números desplazándose ante sus ojos. ¡Ahora puedes ver esto!)

#### Cinco carteras
- Imagina cinco billeteras con diferentes cantidades de dinero en efectivo. Almacene estos cinco valores en una lista e imprima las siguientes oraciones:
     - "La billetera más gorda tiene \$ *valor* en ella".
     - "La billetera más delgada tiene \$ *valor* en ella".
     - "Todos juntos, estas carteras tienen $ *valor* en ellas".

Lista de Comprensiones (List comprehensions)
===
Pensé cuidadosamente antes de incluir esta sección. Si eres nuevo en la programación, la listas de comprensión puede parecer confusa al principio. Son una forma abreviada de crear y trabajar con listas. Es bueno estar al tanto de las listas de comprensión, ya que las verá en el código de otras personas, y son realmente útiles cuando entiende cómo usarlas. Dicho esto, si aún no tienen sentido para ti, no te preocupes por usarlos de inmediato. Cuando hayas trabajado con suficientes listas, querrás usar las comprensiones. Por ahora, es lo suficientemente bueno como para saber que existen y reconocerlos cuando los ves. Si te gustan, sigue adelante y comienza a tratar de usarlas ahora.

Comprensiones Numéricas
---
Consideremos cómo podemos hacer una lista de los primeros diez números cuadrados. Podríamos hacerlo así:
"""

# Store the first ten square numbers in a list.
# Make an empty list that will hold our square numbers.
squares = []

# Go through the first ten numbers, square them, and add them to our list.
for number in range(1,11):
    new_square = number**2
    squares.append(new_square)
    
# Show that our list is correct.
for square in squares:
    print(square)

"""Esto debería tener sentido en este punto. Si no es así, repase el código con estos pensamientos en mente:
- Hacemos una lista vacía llamada *squares* que contendrá los valores que nos interesan.
- Usando la función *range()*, comenzamos un ciclo que recorrerá los números 1-10.
- Cada vez que pasamos por el bucle, encontramos el cuadrado del número actual al elevarlo a la segunda potencia.
- Agregamos este nuevo valor a nuestra lista *squares*.
- Repasamos nuestra lista recién definida e imprimimos cada cuadrado.

Ahora hagamos este código más eficiente. Realmente no necesitamos almacenar el nuevo cuadrado en su propia variable *new_square*; Simplemente podemos agregarlo directamente a la lista de cuadrados. La línea

     new_square = number ** 2

Se saca, y la siguiente línea se encarga de la cuadratura:
"""

# Store the first ten square numbers in a list.
# Make an empty list that will hold our square numbers.
squares = []

# Go through the first ten numbers, square them, and add them to our list.
for number in range(1,11):
    squares.append(number**2)
    
# Show that our list is correct.
for square in squares:
    print(square)

"""Las comprensiones de listas nos permiten colapsar las primeras tres líneas de código en una sola línea. Esto es lo que parece:"""

# Store the first ten square numbers in a list.
squares = [number**2 for number in range(1,11)]

# Show that our list is correct.
for square in squares:
    print(square)

"""Debe quedar bastante claro que este código es más eficiente que nuestro enfoque anterior, pero puede que no quede claro qué está sucediendo. Echemos un vistazo a todo lo que está sucediendo en esa primera línea:

Definimos una lista llamada *squares*.

Mira la segunda parte de lo que está entre corchetes:

     for number in range(1,11)

Esto configura un bucle que recorre los números 1-10, almacenando cada valor en la variable *number*. Ahora podemos ver qué pasa con cada *number* en el bucle:

     number**2

Cada número se eleva a la segunda potencia, y este es el valor que se almacena en la lista que definimos. Podríamos leer esta línea de la siguiente manera:

    squares = [raise *number* to the second power, for each *number* in the range 1-10]

### Otro ejemplo
Probablemente sea útil ver algunos ejemplos más de cómo se pueden usar las comprensiones. Intentemos hacer los primeros diez números pares, la forma más larga:
"""

# Make an empty list that will hold the even numbers.
evens = []

# Loop through the numbers 1-10, double each one, and add it to our list.
for number in range(1,11):
    evens.append(number*2)
    
# Show that our list is correct:
for even in evens:
    print(even)

"""Aquí es cómo podemos pensar en hacer lo mismo, utilizando una lista de comprensión:

    evens = [multiply each *number* by 2, for each *number* in the range 1-10]
    
Aquí está la misma línea en el código:
"""

###highlight=[2,3]
# Make a list of the first ten even numbers.
evens = [number*2 for number in range(1,11)]

for even in evens:
    print(even)

"""Comprensiones no numéricas
---
Podemos usar también las comprensiones con listas no numéricas. En este caso, crearemos una lista inicial y luego usaremos una comprensión para hacer una segunda lista a partir de la primera. Aquí hay un ejemplo simple, sin usar comprensiones:
"""

# Consider some students.
students = ['bernice', 'aaron', 'cody']

# Let's turn them into great students.
great_students = []
for student in students:
    great_students.append(student.title() + " the great!")

# Let's greet each great student.
for great_student in great_students:
    print("Hello, " + great_student)

"""Para usar una comprensión en este código, queremos escribir algo como esto:

    great_students = [add 'the great' to each *student*, for each *student* in the list of *students*]

Y queda así:
"""

###highlight=[5,6]
# Consider some students.
students = ['bernice', 'aaron', 'cody']

# Let's turn them into great students.
great_students = [student.title() + " the great!" for student in students]

# Let's greet each great student.
for great_student in great_students:
    print("Hello, " + great_student)

"""Ejercicios
---
Si estos ejemplos tienen sentido, sigue adelante e intente realizar los siguientes ejercicios utilizando las comprensiones. Si no, prueba los ejercicios sin comprensiones. Puede descubrir cómo usar las comprensiones una vez que haya resuelto cada ejercicio a lo largo.

#### Múltiplos de diez
- Haz una lista de los diez primeros múltiplos de diez (10, 20, 30 ... 90, 100). Hay varias formas de hacerlo, pero trate de hacerlo utilizando una lista de comprensión. Imprime tu lista.

#### Cubos
- Vimos cómo hacer una lista de los primeros diez cuadrados. Haga una lista de los primeros diez cubos (1, 8, 27 ... 1000) utilizando una lista de comprensión, e imprímalos.

#### Increíble
- Almacenar cinco nombres en una lista. Haga una segunda lista que agregue la frase "¡es increíble!" a cada nombre, utilizando una lista de comprensión. Imprime la versión impresionante de los nombres.

#### Trabajando al revés
- Escriba el siguiente código sin usar una lista de comprensión:

    plus_thirteen = [number + 13 for number in range(1,11)]

Cadenas como listas
===
Ahora que tiene cierta familiaridad con las listas, podemos echar un segundo vistazo a las cadenas. Una cadena es realmente una lista de caracteres, por lo que muchos de los conceptos de trabajar con listas se comportan igual con las cadenas.

Cadenas como una lista de caracteres
---
Podemos recorrer una cadena usando un bucle *for*, como lo hacemos en una lista:
"""

message = "Hello!"

for letter in message:
    print(letter)

"""Podemos crear una lista a partir de una cadena. La lista tendrá un elemento para cada carácter en la cadena:"""

message = "Hello world!"

message_list = list(message)
print(message_list)

"""Rebanadas de cadenas
---
Podemos acceder a cualquier carácter de una cadena por su posición, al igual que accedemos a elementos individuales en una lista:
"""

message = "Hello World!"
first_char = message[0]
last_char = message[-1]

print(first_char, last_char)

"""Podemos extender esto para tomar cortes de una cadena:"""

message = "Hello World!"
first_three = message[:3]
last_three = message[-3:]

print(first_three, last_three)

"""Encontrando subcadenas
---
Ahora que has visto lo que significan los índices para las cadenas, podemos buscar *subcadenas*. Una subcadena es una serie de caracteres que aparecen en una cadena.

Puede usar la palabra clave *in* para averiguar si una subcadena en particular aparece en una cadena:
"""

message = "I like cats and dogs."
dog_present = 'dog' in message
print(dog_present)

"""Si deseas saber dónde aparece una subcadena en una cadena, puede usar el método *find()*. El método *find()* le indica el índice en el que comienza la subcadena."""

message = "I like cats and dogs."
dog_index = message.find('dog')
print(dog_index)

"""Sin embargo, ten en cuenta que esta función solo devuelve el índice de la primera aparición de la subcadena que está buscando. Si la subcadena aparece más de una vez, perderá las otras subcadenas."""

###highlight=[2]
message = "I like cats and dogs, but I'd much rather own a dog."
dog_index = message.find('dog')
print(dog_index)

"""Si desea encontrar la última aparición de una subcadena, puede usar la función *rfind()*:"""

###highlight=[3,4]
message = "I like cats and dogs, but I'd much rather own a dog."
last_dog_index = message.rfind('dog')
print(last_dog_index)

"""Sustitución de subcadenas
---
Puede usar la función * replace () * para reemplazar cualquier subcadena con otra subcadena. Para usar la función * replace () *, especifique la subcadena que desea reemplazar y luego la subcadena con la que desea reemplazarla. También debe almacenar la nueva cadena, ya sea en la misma variable de cadena o en una nueva variable.
"""

message = "I like cats and dogs, but I'd much rather own a dog."
message = message.replace('dog', 'snake')
print(message)

"""Contando subcadenas
---
Si desea saber cuántas veces aparece una subcadena dentro de una cadena, puede usar el método *count()*.
"""

message = "I like cats and dogs, but I'd much rather own a dog."
number_dogs = message.count('dog')
print(number_dogs)

"""Dividir cadenas
---
Las cadenas se pueden dividir en un conjunto de subcadenas cuando están separadas por un carácter repetido. Si una cadena consta de una oración simple, la cadena se puede dividir en función de los espacios. La función *split()* devuelve una lista de subcadenas. La función *split()* toma un argumento, el carácter que separa las partes de la cadena.
"""

message = "I like cats and dogs, but I'd much rather own a dog."
words = message.split(' ')
print(words)

"""Observa que la puntuación se deja en las subcadenas.

Es más común dividir cadenas que son realmente listas, separadas por algo como una coma. La función * split () * te brinda una manera fácil de convertir cadenas separadas por comas, con las que no puedes hacer mucho en Python, en listas. Una vez que tenga sus datos en una lista, puede trabajar con ellos de maneras mucho más poderosas.
"""

animals = "dog, cat, tiger, mouse, liger, bear"

# Rewrite the string as a list, and store it in the same variable
animals = animals.split(',')
print(animals)

"""Ten en cuenta que en este caso, los espacios también se ignoran. Es una buena idea probar la salida de la función *split()* y asegurarse de que está haciendo lo que quiere con los datos que le interesan.

Un uso de esto es trabajar con datos de hoja de cálculo en sus programas de Python. La mayoría de las aplicaciones de hoja de cálculo le permiten volcar sus datos en un archivo de texto separado por comas. Puede leer este archivo en su programa Python, o incluso copiar y pegar desde el archivo de texto a su archivo de programa, y luego convertir los datos en una lista. Luego, puede procesar los datos de su hoja de cálculo utilizando un bucle *for*.

Ejercicios
---
#### Listado de una oración
- Almacenar una sola frase en una variable. Use un bucle for para imprimir cada carácter de su oración en una línea separada.

#### Lista de oraciones
- Almacenar una sola frase en una variable. Crea una lista de tu oración. Imprima su lista en bruto (no use un bucle, solo imprima la lista).

#### Slices de oración
- Almacenar una oración en una variable. Usando cortes, imprima los primeros cinco caracteres, cinco caracteres consecutivos desde la mitad de la oración y los últimos cinco caracteres de la oración.

#### Buscando a Python
- Almacene una oración en una variable, asegurándose de usar la palabra *Python* al menos dos veces en la oración.
- Use la palabra clave *in* para demostrar que la palabra *Python* está realmente en la oración.
- Use la función *find()* para mostrar dónde aparece la palabra *Python* por primera vez en la oración.
- Use la función *rfind()* para mostrar el último lugar donde aparece *Python* en la oración.
- Use la función *count()* para mostrar cuántas veces aparece la palabra *Python* en su oración.
- Use la función *split()* para dividir su oración en una lista de palabras. Imprima la lista sin procesar y use un bucle para imprimir cada palabra en su propia línea.
- Use la función *replace()* para cambiar *Python* a *Ruby* en su oración.

Tuplas
===
Las tuplas son básicamente listas que nunca se pueden cambiar. Las listas son bastante dinámicas; pueden crecer a medida que se agregan e insertan elementos, y pueden reducirse a medida que se eliminan. Puedes modificar cualquier elemento que desee en una lista. A veces nos gusta este comportamiento, pero otras veces queremos asegurarnos de que ningún usuario o parte de un programa pueda cambiar una lista. Para eso están las tuplas.

Técnicamente, las listas son objetos *mutables* y las tuplas son objetos *inmutables*. Los objetos mutables pueden cambiar (piense en *mutaciones*), y los objetos inmutables no pueden cambiar.

Definiendo tuplas, y accediendo a elementos.
---

Se define una tupla como se define una lista, excepto que usa paréntesis en lugar de corchetes. Una vez que tenga una tupla, puede acceder a elementos individuales al igual que con una lista, y puede recorrer la tupla con un bucle *for*:
"""

colors = ('red', 'green', 'blue')
print("The first color is: " + colors[0])

print("\nThe available colors are:")
for color in colors:
    print("- " + color)

"""Si intentas agregar algo a una tupla, obtendrás un error:"""

colors = ('red', 'green', 'blue')
colors.append('purple') # :(

"""Lo mismo sucede cuando intentas eliminar algo de una tupla o modificar uno de sus elementos. Una vez que defines una tupla, puedes estar seguro de que sus valores no cambiarán.

Usando tuplas para hacer cadenas
---
Hemos visto que es bastante útil poder mezclar cadenas sin procesar con valores que se almacenan en variables, como se muestra a continuación:
"""

animal = 'dog'
print("I have a " + animal + ".")

"""Esto fue especialmente útil cuando tuvimos que hacer una serie de declaraciones similares:"""

animals = ['dog', 'cat', 'bear']
for animal in animals:
    print("I have a " + animal + ".")

"""Me gusta este enfoque de usar el signo más para construir cadenas porque es bastante intuitivo. Podemos ver que estamos agregando varias cadenas más pequeñas para hacer una cadena más larga. Esto es intuitivo, pero es mucho escribir. Hay una forma más corta de hacer esto, usando *placeholdets* o marcadores de posición.

Python ignora la mayoría de los caracteres que ponemos dentro de las cadenas. Python presta atención a algunos caracteres, como vimos con cadenas como "\t" y "\n". Python también presta atención a "%s" y "%d". Estos son marcadores de posición. Cuando Python ve el marcador de posición "%s", mira hacia adelante y extrae el primer argumento después del signo %:
"""

animal = 'dog'
print("I have a %s." % animal)

animal = 'dog'
print("I have a {0}".format(animal))

"""Esta es una forma mucho más limpia de generar cadenas que incluyen valores. Componemos nuestra oración, todo en una cadena, y luego le decimos a Python qué valores colocar en la cadena, en los lugares apropiados.

Esto se denomina *string formatting* y se ve igual cuando se usa una lista:
"""

animals = ['dog', 'cat', 'bear']
for animal in animals:
    print("I have a %s." % animal)

animals = ['dog', 'cat', 'bear']

for animal in animals:
    print("I have a {}".format(animal))

"""Si tienes más de un valor para poner en la cadena que está componiendo, debes empaquetar los valores en una tupla:"""

animals = ['dog', 'cat', 'bear']
print("I have a %s, a %s, and a %s." % (animals[0], animals[1], animals[2]))

animals = ['dog', 'cat', 'bear']

print("I have a {2}, {1}, {0}".format(animals[0],animals[1],animals[2]))

"""### Formato de cadena con números

Si recuerdas, imprimir un número con una cadena puede causar un error:
"""

number = 23
print("My favorite number is " + number + ".") #:(

"""Python sabe que podrías estar hablando sobre el valor 23, o los caracteres '23'. Así que produce un error, lo que nos obliga a aclarar que queremos que Python trate el número como una cadena. Hacemos esto al *castear* el número en una cadena usando la función *str()*:"""

number = 23
print("My favorite number is " + str(number) + ".")

"""La cadena de formato "%d" se encarga de esto por nosotros. Mira lo limpio que es este código:"""

###highlight=[3]
number = 23
print("My favorite number is %d." % number)

"""Si deseas usar una serie de números, los empacas en una tupla tal como vimos con cadenas:"""

numbers = [7, 23, 42]
print("My favorite numbers are %d, %d, and %d." % (numbers[0], numbers[1], numbers[2]))

"""Solo para aclarar, mire cuánto más largo es el código si usa concatenación en lugar de formato de cadena:"""

###highlight=[3]
numbers = [7, 23, 42]
print("My favorite numbers are " + str(numbers[0]) + ", " + str(numbers[1]) + ", and " + str(numbers[2]) + ".")

"""Puede mezclar marcadores de posición numéricos y de cadena en el orden que desee."""

names = ['eric', 'ever']
numbers = [23, 2]
print("%s's favorite number is %d, and %s's favorite number is %d." % (names[0].title(), numbers[0], names[1].title(), numbers[1]))

"""Hay formas más sofisticadas de realizar el formateo de cadenas en Python 3, pero lo guardaremos para más adelante porque es un poco menos intuitivo que este enfoque. Por ahora, puedes usar cualquier enfoque que consiga de manera consistente la salida que desea ver.

Estilo de codificación: PEP 8
===

Ahora estás empezando a escribir programas de Python que tienen poca sustancia. Tus programas están creciendo un poco más, y hay un poco más de estructura en sus programas. Este es un buen momento para considerar su estilo general al escribir el código.

¿Por qué necesitamos convenciones de estilo?
---

Las personas que originalmente desarrollaron Python tomaron algunas de sus decisiones basadas en la comprensión de que el código se lee con mucha más frecuencia de lo que está escrito. Los desarrolladores originales prestaron tanta atención para hacer que el lenguaje sea fácil de leer como para escribir. Python se ha ganado mucho respeto como lenguaje de programación debido a lo legible que es el código. Usted ha visto que Python utiliza la sangría para mostrar qué líneas de un programa se agrupan. Esto hace que la estructura de su código sea visible para cualquiera que lo lea. Sin embargo, hay algunas decisiones de estilo que podemos tomar como programadores que pueden hacer que nuestros programas sean más legibles para nosotros y para otros.

Hay varias audiencias a tener en cuenta cuando piensa en qué tan legible es su código.

#### Tú mismo, dentro de 6 meses
- Sabes lo que estás pensando cuando escribes código por primera vez. Pero, ¿con qué facilidad recordará lo que estaba pensando cuando vuelva a ese código mañana, la próxima semana o dentro de seis meses? Queremos que nuestro código sea tan fácil de leer como sea posible dentro de seis meses, por lo que podemos saltar a nuestros proyectos cuando lo deseemos.

#### Otros programadores con los que te gustaría colaborar
- Cada proyecto significativo es el resultado de la colaboración en estos días. Si permanece en la programación, trabajará con otros en trabajos y en proyectos de código abierto. Si escribe un código legible con buenos comentarios, la gente estará encantada de trabajar con usted en cualquier entorno.

#### Empleadores potenciales
- La mayoría de las personas que contratan programadores le pedirán ver un código que ha escrito, y probablemente le pedirán que escriba un código durante su entrevista. Si tiene la costumbre de escribir un código que sea fácil de leer, le irá bien en estas situaciones.

¿Qué es un PEP?
---
Un PEP es una *Propuesta de mejora de Python*. Cuando las personas desean sugerir cambios al lenguaje Python real, alguien redacta una Propuesta de mejora de Python. Uno de los primeros PEP fue una colección de pautas para escribir código que es fácil de leer. Era PEP 8, la [Guía de estilo para el código de Python](http://www.python.org/dev/peps/pep-0008/). Hay muchas cosas allí que no tendrán sentido para ti todavía por algún tiempo, pero hay algunas sugerencias que debes tener en cuenta desde el principio. Comenzar con buenos hábitos de estilo ahora te ayudará a escribir código limpio desde el principio, lo que también te ayudará a darle sentido a tu código.

Pautas básicas de estilo de Python
---

#### Sangría
- Utiliza 4 espacios para la sangría. Este es espacio suficiente para darle a su código alguna estructura visual, mientras deja espacio para múltiples niveles de sangrado. Hay configuraciones de configuración en la mayoría de los editores para convertir automáticamente las pestañas a 4 espacios, y es una buena idea verificar esta configuración.

#### Longitud de la línea
- Use hasta 79 caracteres por línea de código y 72 caracteres para comentarios. Esta es una guía de estilo que algunas personas se adhieren y otras ignoran completamente. Esto solía relacionarse con un límite en el tamaño de visualización de la mayoría de los monitores. Ahora casi todos los monitores son capaces de mostrar más de 80 caracteres por línea. Pero a menudo trabajamos en terminales, que no siempre son de alta resolución. También nos gusta tener varios archivos de código abiertos, uno junto al otro. Resulta que esta es una guía útil a seguir en la mayoría de los casos. Hay una pauta secundaria de mantener 99 caracteres por línea, si quieres líneas más largas.

    Muchos editores tienen una configuración que muestra una línea vertical que lo ayuda a mantener sus líneas en cierta longitud. 

#### Líneas en blanco
- Usa líneas en blanco para dividir su código en bloques significativos. Has visto esto en muchos ejemplos hasta ahora. Puedes usar dos líneas en blanco en programas más largos, pero no te excedas con las líneas en blanco.

#### Comentarios
- Usa un solo espacio después del signo de libra al principio de una línea. Si estás escribiendo más de un párrafo, usa una línea vacía con un signo de libra entre los párrafos.

#### Nombrando variables
- Nombra las variables y los archivos de programa usando solo letras minúsculas, guiones bajos y números. Python no se quejará ni lanzará errores si usa mayúsculas, pero engañará a otros programadores si usa letras mayúsculas en las variables en este punto.

Eso es todo por ahora. Repasaremos más pautas de estilo a medida que presentemos estructuras de programación más complicadas. Si sigue estas pautas por ahora, estará bien encaminado para escribir un código legible que los profesionales respetarán.
"""